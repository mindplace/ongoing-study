# 1. If we list all the natural numbers below 10 that are multiples of 3 or 5, 
# we get 3, 5, 6 and 9. The sum of these multiples is 23.
# Find the sum of all the multiples of 3 or 5 below 1000.

def sum_of_multiples
    sum = 0
    (1...1000).each do |num|
        sum += num if num % 3 == 0 || num % 5 == 0
    end
    sum
end

# 2. Each new term in the Fibonacci sequence is generated by adding 
# the previous two terms. By starting with 1 and 2, the first 10 terms will be:

# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

# By considering the terms in the Fibonacci sequence whose values do not exceed 
# four million, find the sum of the even-valued terms.

def fibonacci_sum
    fib_array = [1, 2]
    while fib_array.last < 4000000
        fib_array << fib_array[-1] + fib_array[-2]
    end
    fib_array.select{|num| num % 2 == 0}.inject(:+)
end

# 3. The prime factors of 13195 are 5, 7, 13 and 29.
# What is the largest prime factor of the number 600851475143 ?

def helper(num)
    prime = true
    (2...num).each{|x| 
        prime = false if num % x == 0
        break if prime == false
    }
    prime
end

def largest_prime_factor(number)
    x = 2
    prime = []
    product = 1
    while product < number
        if ((number % x == 0) && (helper(x) == true))
            prime << x
            product *= x
        end
        x += 1
    end
    prime.last
end

#puts largest_prime_factor(13195)
#puts largest_prime_factor(600_851_475_143)

# 4. A palindromic number reads the same both ways. 
# The largest palindrome made from the product of two 2-digit numbers 
# is 9009 = 91 × 99.
# Find the largest palindrome made from the product of two 3-digit numbers.

def factors(array)
    multiples = []
    array.each_with_index do |num, i|
        while i < array.length
            multiples << num * array[i]
            i += 1
        end
    end
    multiples
end
            
def palindromic
    palindrome_array = (998001.downto(10000)).to_a.select{|x| x == x.to_s.reverse.to_i}
    palindrome = []
    palindrome_array.each do |i|
        factor_array = (100..999).to_a.select{|x| i % x == 0}
        palindrome << i if factors(factor_array).include?(i)
        break if palindrome.length == 1
    end
    palindrome[0]
end
        
# puts palindromic

# 5. 2520 is the smallest number that can be divided by 
# each of the numbers from 1 to 10 without any remainder.
# What is the smallest positive number that is evenly 
# divisible by all of the numbers from 1 to 20?

def least_common(a, b)
    lcm = a
    while (lcm % b != 0)
        lcm += a
    end
    lcm
end

def iterates(array)
    next_branch = []
    array.each_with_index do |num, i|
        break if array[i] == array.last
        next_branch << least_common(array[i], array[i + 1])
    end
    next_branch
end

def smallest_multiple
    factor_array = (1..20).to_a
    next_branch = iterates(factor_array)
    while next_branch.length > 1
        next_branch = iterates(next_branch)
    end
    next_branch[0]
end

# puts smallest_multiple

# 6. The sum of the squares of the first ten natural numbers is,
#   (1**2 + 2**2 + ... + 10**2) = 385
# The square of the sum of the first ten natural numbers is,
#   (1 + 2 + ... + 10)**2 = 55**2 = 3025
# Hence the difference between the sum of the squares of the first ten 
# natural numbers and the square of the sum is 3025 − 385 = 2640.
# Find the difference between the sum of the squares of the 
# first one hundred natural numbers and the square of the sum.

def sum_square_diff
    range = (1..100).to_a
    square = range.inject(:+) ** 2
    sum = range.map{|i| i ** 2}.inject(:+)
    square - sum
end

# puts sum_square_diff

# 7. By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, 
# we can see that the 6th prime is 13.
# What is the 10 001st prime number?

def find_prime
    primes = [2, 3, 5, 7]
    current_prime = 7
    now = Time.now
    while true
        testing_num = current_prime + 2
        while true 
            if ((2..((testing_num / 2) + 1)).to_a.select{|x| testing_num % x == 0} != [])
                testing_num += 2
            else
                break
            end
        end
        # This solution works even though it takes 240.08 seconds;
        # I've optimized it for speed by altering how I test numbers for being prime, 
        # but that's not been enough to make it faster. Can't figure out
        # a non-brute force method to solve this problem. 
        current_prime = testing_num
        primes << current_prime
        break if primes.size == 10001
    end
    puts primes.last
    puts (Time.now - now)
end

# find_prime


